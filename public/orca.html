<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orca Regime + Pool Rankings</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #070b13;
        --bg-2: #0a1222;
        --panel: rgba(17, 26, 43, 0.96);
        --panel-2: rgba(13, 20, 34, 0.96);
        --text: #eef4ff;
        --muted: #94a3be;
        --line: rgba(134, 169, 230, 0.18);
        --line-strong: rgba(134, 169, 230, 0.3);
        --accent: #66e0d0;
        --accent-2: #5bb7ff;
        --accent-3: #7ef5ff;
        --warn: #ffb13b;
        --danger: #ff6d6d;
        --ok: #70f2a8;
        --shadow: 0 18px 50px rgba(2, 8, 22, 0.45);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", system-ui, sans-serif;
        color: var(--text);
        background:
          radial-gradient(circle at 10% 12%, rgba(72, 111, 191, 0.34) 0%, transparent 38%),
          radial-gradient(circle at 88% 14%, rgba(36, 144, 124, 0.28) 0%, transparent 42%),
          radial-gradient(circle at 55% 120%, rgba(36, 92, 160, 0.18) 0%, transparent 52%),
          linear-gradient(180deg, var(--bg-2), var(--bg));
      }

      .wrap {
        width: min(1280px, 94vw);
        margin: 26px auto 72px;
        padding: 0;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 18px;
      }

      .header-right {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .header-pill {
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 8px 10px;
        background: rgba(15, 23, 40, 0.75);
        min-width: 220px;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      }

      .header-pill .title {
        color: var(--muted);
        font-size: 0.72rem;
        margin-bottom: 2px;
      }

      .header-pill .value {
        font-weight: 700;
        font-size: 0.95rem;
        font-family: "IBM Plex Mono", monospace;
      }

      .btn {
        border: 1px solid rgba(146, 255, 248, 0.28);
        border-radius: 12px;
        padding: 8px 12px;
        background: linear-gradient(135deg, var(--accent) 0%, #42d6f7 60%, #66b3ff 100%);
        color: #06111b;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 700;
        box-shadow: 0 10px 24px rgba(64, 190, 217, 0.22);
      }

      .btn[disabled] {
        opacity: 0.7;
        cursor: wait;
      }

      .operator-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        color: var(--muted);
        font-size: 0.82rem;
      }

      .operator-toggle input {
        accent-color: var(--accent);
      }

      .operator-wallet {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px 10px;
        background: rgba(15, 23, 40, 0.8);
        color: var(--text);
        min-width: 260px;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.78rem;
      }

      .operator-panel .panel-grid {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }

      .operator-panel pre {
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.75rem;
        color: #d2e7ff;
      }

      .operator-panel textarea {
        width: 100%;
        min-height: 148px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: rgba(15, 23, 40, 0.85);
        color: #d2e7ff;
        font-family: "IBM Plex Mono", monospace;
        font-size: 0.75rem;
        padding: 10px;
        resize: vertical;
      }

      .operator-panel .copy-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }

      .operator-panel .copy-btn {
        border: 1px solid var(--line-strong);
        border-radius: 10px;
        background: rgba(15, 23, 40, 0.9);
        color: var(--text);
        padding: 6px 10px;
        font-size: 0.78rem;
        cursor: pointer;
      }

      .operator-panel .copy-status {
        color: var(--muted);
        font-size: 0.78rem;
      }

      .hidden {
        display: none !important;
      }


      .nav-link {
        color: var(--accent-3);
        text-decoration: none;
      }

      h1 {
        margin: 0;
        font-size: 1.6rem;
        letter-spacing: -0.02em;
      }

      .muted {
        color: var(--muted);
      }

      .card {
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid var(--line);
        border-radius: 20px;
        box-shadow: var(--shadow);
        backdrop-filter: blur(8px);
      }

      .regime {
        padding: 18px;
        margin-bottom: 18px;
      }

      .regime-top {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 8px 12px;
        font-weight: 700;
        letter-spacing: 0.04em;
        border: 1px solid var(--line);
        background: rgba(15, 23, 40, 0.75);
      }

      .pill.low { color: var(--ok); }
      .pill.moderate { color: var(--warn); }
      .pill.high { color: var(--danger); }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 10px;
      }

      .metric {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px 12px;
        background: rgba(15, 23, 40, 0.75);
      }

      .metric .label {
        color: var(--muted);
        font-size: 0.75rem;
        margin-bottom: 4px;
      }

      .metric .value {
        font-weight: 700;
        font-size: 1rem;
      }

      .reasons {
        margin-top: 12px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .reasons ul {
        margin: 6px 0 0;
        padding-left: 18px;
      }

      .table-card {
        overflow: hidden;
      }

      .stack {
        display: grid;
        gap: 18px;
      }

      .section {
        padding: 14px 16px;
      }

      .section h2 {
        margin: 0 0 10px;
        font-size: 1rem;
        letter-spacing: 0.02em;
      }

      .grid-2 {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 10px;
      }

      .mini-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        background: rgba(15, 23, 40, 0.75);
      }

      .mini-card h3 {
        margin: 0 0 6px;
        font-size: 0.95rem;
      }

      .kv {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 4px 10px;
        font-size: 0.86rem;
      }

      .kv .k {
        color: var(--muted);
      }

      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .chip {
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 3px 8px;
        font-size: 0.75rem;
        color: var(--muted);
      }


      .portfolio-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 10px;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 3px 8px;
        font-size: 0.75rem;
        font-weight: 700;
        letter-spacing: 0.04em;
        border: 1px solid var(--line);
      }

      .status-pill.green { color: var(--ok); }
      .status-pill.yellow { color: var(--warn); }
      .status-pill.orange { color: #ff9f5a; }
      .status-pill.red { color: var(--danger); }

      .cadence-control {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 4px;
      }

      .cadence-btn {
        border: 0;
        border-radius: 999px;
        padding: 6px 10px;
        cursor: pointer;
        color: var(--muted);
        background: transparent;
        font-size: 0.78rem;
      }

      .cadence-btn.active {
        background: rgba(41, 211, 196, 0.2);
        color: var(--text);
      }

      .preset-recommended {
        border: 1px solid rgba(112, 242, 168, 0.45);
        border-radius: 8px;
        padding: 3px 6px;
        background: rgba(112, 242, 168, 0.08);
      }

      .alert-list {
        display: grid;
        gap: 8px;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }

      .input {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--line);
        color: var(--text);
        border-radius: 10px;
        padding: 8px 10px;
        min-width: 140px;
      }

      .calc-table td, .calc-table th {
        font-size: 0.86rem;
      }

      .calc-table thead th {
        position: static;
        top: auto;
        z-index: auto;
        box-shadow: none;
      }

      .gauge {
        width: 100%;
        height: 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid var(--line);
        overflow: hidden;
      }

      .gauge-fill {
        height: 100%;
        width: 0%;
        transition: width 160ms ease;
      }

      .gauge-fill.green { background: linear-gradient(90deg, #2ccf9c, #70f2a8); }
      .gauge-fill.yellow { background: linear-gradient(90deg, #f0a93a, #ffcf6f); }
      .gauge-fill.red { background: linear-gradient(90deg, #ff6d6d, #ff9b9b); }

      .alert {
        border-radius: 10px;
        padding: 10px 12px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.02);
        font-size: 0.9rem;
      }

      .alert.warn { border-color: rgba(255, 177, 59, 0.35); }
      .alert.critical { border-color: rgba(255, 109, 109, 0.35); }
      .alert.info { border-color: rgba(41, 211, 196, 0.25); }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      thead th {
        text-align: left;
        font-size: 0.75rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: var(--muted);
        padding: 12px 10px;
        border-bottom: 1px solid var(--line);
        background: rgba(8, 14, 22, 0.98);
        position: sticky;
        top: 0;
        z-index: 2;
        box-shadow: 0 1px 0 rgba(155, 177, 203, 0.14);
      }

      tbody td {
        padding: 10px;
        border-bottom: 1px solid rgba(155, 177, 203, 0.1);
        vertical-align: top;
        font-size: 0.9rem;
      }

      tbody tr:hover {
        background: rgba(255, 255, 255, 0.02);
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 0.82rem;
      }

      .score {
        font-weight: 700;
        color: var(--accent);
      }

      .status {
        margin: 10px 0 18px;
        color: var(--muted);
      }

      .error {
        color: #ffd0d0;
        border: 1px solid rgba(255, 109, 109, 0.3);
        background: rgba(255, 109, 109, 0.08);
        padding: 12px;
        border-radius: 12px;
      }

      .table-wrap {
        overflow: auto;
        max-height: 68vh;
        position: relative;
      }

      @media (max-width: 900px) {
        .wrap {
          padding: 14px;
        }
        thead th, tbody td {
          padding: 8px 6px;
          font-size: 0.82rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <h1>Orca Regime + Pool Rankings</h1>
        <div class="header-right">
          <a class="btn nav-link" href="/">Back to Main Dashboard</a>
          <label class="operator-toggle"><input id="operatorModeToggleOrca" type="checkbox" /> Operator Mode</label>
          <input
            id="operatorWalletInputOrca"
            class="operator-wallet"
            type="text"
            placeholder="Operator wallet for /api/positions summary"
          />
          <button id="refreshBtn" class="btn" type="button">Refresh</button>
          <button id="refreshLiveSpotBtn" class="btn" type="button">Refresh Live Prices</button>
          <div id="liveSpotCard" class="header-pill">
            <div class="title">Live Prices</div>
            <div class="value" id="liveSpotValue">Loading...</div>
            <div class="muted" id="liveSpotUpdated" style="font-size:0.75rem;"></div>
            <div class="muted" id="liveSpotError" style="font-size:0.75rem; color:#ffd0d0;"></div>
          </div>
          <div id="updatedAt" class="muted"></div>
          <div id="lastRefreshAttempt" class="muted"></div>
          <div id="refreshInlineError" class="muted" style="color:#ffd0d0;"></div>
        </div>
      </div>
      <div id="status" class="status">Loading Orca dashboard data...</div>
      <div id="app"></div>
    </div>

    <script>
      const REGIME_URL = "/data/orca/regime_state.json";
      const POOLS_URL = "/data/orca/pool_rankings.json";
      const SHORTLIST_URL = "/data/orca/shortlist.json";
      const PLANS_URL = "/data/orca/plans.json";
      const ALLOCATION_URL = "/data/orca/allocation.json";
      const ALERTS_URL = "/data/orca/alerts.json";
      const PERFORMANCE_URL = "/data/orca/performance.json";
      const POSITIONS_SUMMARY_URL = "/api/positions";
      const LIVE_SOL_SPOT_PROXY_URL = "/api/sol-spot";
      const LIVE_SOL_SPOT_URL = "https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd";
      const ORCA_OPERATOR_MODE_KEY = "orcaOperatorModeEnabled";
      const ORCA_OPERATOR_WALLET_KEY = "orcaOperatorWallet";
      const DEFAULT_OPERATOR_WALLET = "4ogWhtiSEAaXZCDD9BPAnRa2DY18pxvF9RbiUUdRJSvr";
      const runtimeState = {
        latestData: null,
        latestPositionsSummary: null,
        operatorSummaryError: null,
        calc: null,
        liveSpot: {
          priceUsd: null,
          updatedAt: null,
          source: "coingecko",
          error: null
        },
        monitorCadenceHours: Number(localStorage.getItem("monitorCadenceHours") || 24) === 48 ? 48 : 24,
        livePrices: {
          byMint: {},
          bySymbol: {},
          updatedAt: null,
          error: null
        }
      };
      const operatorModeToggleOrca = document.getElementById("operatorModeToggleOrca");
      const operatorWalletInputOrca = document.getElementById("operatorWalletInputOrca");

      function loadOrcaOperatorModeState() {
        try {
          return localStorage.getItem(ORCA_OPERATOR_MODE_KEY) === "1";
        } catch {
          return false;
        }
      }

      function persistOrcaOperatorModeState(enabled) {
        try {
          localStorage.setItem(ORCA_OPERATOR_MODE_KEY, enabled ? "1" : "0");
        } catch {}
      }

      function loadOrcaOperatorWallet() {
        const qsWallet = new URLSearchParams(window.location.search).get("wallet");
        if (qsWallet && qsWallet.trim()) return qsWallet.trim();
        try {
          const stored = localStorage.getItem(ORCA_OPERATOR_WALLET_KEY);
          if (stored && stored.trim()) return stored.trim();
        } catch {}
        return DEFAULT_OPERATOR_WALLET;
      }

      function persistOrcaOperatorWallet(wallet) {
        try {
          localStorage.setItem(ORCA_OPERATOR_WALLET_KEY, wallet);
        } catch {}
      }

      runtimeState.operatorModeEnabled = loadOrcaOperatorModeState();
      runtimeState.operatorWallet = loadOrcaOperatorWallet();
      if (operatorModeToggleOrca) operatorModeToggleOrca.checked = runtimeState.operatorModeEnabled;
      if (operatorWalletInputOrca) operatorWalletInputOrca.value = runtimeState.operatorWallet;
      const STABLE_SYMBOLS = new Set(["USDC", "USDT", "USDG", "USDE", "DAI", "USDS", "USD1", "PYUSD", "ONYC"]);
      const KNOWN_STABLE_MINTS = new Set([
        "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        "Es9vMFrzaCER7h3Yb9g4Z1cdq9VHtV6nRvWmvMRGsiE"
      ]);

      function isMissingValue(v) {
        return v == null || v === "";
      }

      function fmtUsd(v) {
        if (isMissingValue(v)) return "n/a";
        const n = Number(v);
        if (!Number.isFinite(n)) return "n/a";
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: "USD",
          maximumFractionDigits: n >= 1000 ? 0 : 2
        }).format(n);
      }

      function fmtPct(v, digits = 2) {
        if (isMissingValue(v)) return "n/a";
        const n = Number(v);
        if (!Number.isFinite(n)) return "n/a";
        return `${n.toFixed(digits)}%`;
      }

      function fmtNum(v, digits = 2) {
        if (isMissingValue(v)) return "n/a";
        const n = Number(v);
        if (!Number.isFinite(n)) return "n/a";
        return n.toFixed(digits);
      }

      function fmtTime(v) {
        if (!v) return "n/a";
        const d = new Date(v);
        return Number.isNaN(d.getTime()) ? "n/a" : d.toLocaleTimeString();
      }

      function normSymbol(s) {
        return String(s || "").replace(/[^a-z0-9]/gi, "").toUpperCase();
      }

      function displayTokenAmount(amount, symbol, decimals, priceUsd) {
        const n = Number(amount);
        if (!Number.isFinite(n)) return "—";
        const stable = (Number.isFinite(Number(priceUsd)) && Math.abs(Number(priceUsd) - 1) < 0.05) || STABLE_SYMBOLS.has(normSymbol(symbol));
        const maxFrac = stable ? 2 : Number(decimals) >= 9 ? 6 : 4;
        return `${n.toLocaleString(undefined, { maximumFractionDigits: maxFrac })} ${symbol || ""}`.trim();
      }

      function regimeClass(label) {
        return String(label || "").toLowerCase();
      }

      function escapeHtml(s) {
        return String(s ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;");
      }


      function getOperatorMode(cadenceHours) {
        if (Number(cadenceHours) === 48) {
          return {
            monitorCadenceHours: 48,
            name: "EVERY_48H",
            deltaTolerance: 0.15,
            minLiqBufferPct: 0.2,
            presetBias: "CONSERVATIVE",
            warnEdgePct: 0.35,
            actEdgePct: 0.18
          };
        }
        return {
          monitorCadenceHours: 24,
          name: "DAILY",
          deltaTolerance: 0.3,
          minLiqBufferPct: 0.12,
          presetBias: "BASE",
          warnEdgePct: 0.25,
          actEdgePct: 0.1
        };
      }

      function portfolioIndexUrlForCadence(cadenceHours) {
        const cadence = Number(cadenceHours) === 48 ? 48 : 24;
        return `/data/portfolio/cadence_${cadence}/systems_index.json`;
      }

      function renderCadenceControl() {
        const cadence = Number(runtimeState.monitorCadenceHours) === 48 ? 48 : 24;
        return `<div class="cadence-control" role="group" aria-label="Monitoring cadence">
          <span class="muted" style="font-size:0.78rem; margin-left:6px;">Monitoring cadence</span>
          <button class="cadence-btn ${cadence === 24 ? "active" : ""}" data-cadence="24" type="button">Daily (24h)</button>
          <button class="cadence-btn ${cadence === 48 ? "active" : ""}" data-cadence="48" type="button">Every 48h</button>
        </div>`;
      }

      function cadenceRangeAlerts(plans) {
        const mode = getOperatorMode(runtimeState.monitorCadenceHours);
        const rows = Array.isArray(plans?.plans) ? plans.plans : [];
        const alerts = [];
        for (const p of rows) {
          const preferredLabel = p.recommendedPreset || (mode.presetBias === "CONSERVATIVE" ? "Conservative" : "Base");
          const preferred = (p.presets || []).find((x) => x.label === preferredLabel) || (p.presets || []).find((x) => x.label === "Base");
          const half = Number(preferred?.halfWidthPct);
          if (!Number.isFinite(half) || half <= 0) continue;
          const distanceToEdgePct = half;
          if (distanceToEdgePct <= mode.actEdgePct * 100) {
            alerts.push({
              id: `cadence-action-${p.poolAddress}`,
              severity: "critical",
              kind: "RANGE_EDGE_ACTION",
              pool: p.pool,
              message: `${p.pool}: action threshold hit (${fmtNum(distanceToEdgePct, 2)}% <= ${fmtNum(mode.actEdgePct * 100, 2)}%)`
            });
          } else if (distanceToEdgePct <= mode.warnEdgePct * 100) {
            alerts.push({
              id: `cadence-warn-${p.poolAddress}`,
              severity: "warn",
              kind: "RANGE_EDGE_WARN",
              pool: p.pool,
              message: `${p.pool}: warning threshold hit (${fmtNum(distanceToEdgePct, 2)}% <= ${fmtNum(mode.warnEdgePct * 100, 2)}%)`
            });
          }
        }
        return alerts;
      }

      function renderPortfolioSystems(indexData) {
        const systems = Array.isArray(indexData?.systems) ? indexData.systems : [];
        const mode = getOperatorMode(runtimeState.monitorCadenceHours);
        const healthRollup = indexData?.healthRollup || { overall: "strong" };
        const capitalGuardRollup = indexData?.capitalGuardRollup || { level: "none", triggers: [] };
        return `
          <section class="card section">
            <h2>Portfolio Systems</h2>
            <div class="mini-card" style="margin-bottom:10px;">
              <h3>Portfolio Risk</h3>
              <div class="kv" style="margin-top:6px;">
                <div class="k">Health</div><div>${escapeHtml(String(healthRollup.overall || "strong").toUpperCase())}</div>
                <div class="k">Capital Guard</div><div>${escapeHtml(String(capitalGuardRollup.level || "none").toUpperCase())}</div>
                <div class="k">Triggers</div>
                <div class="chips">
                  ${(Array.isArray(capitalGuardRollup.triggers) && capitalGuardRollup.triggers.length
                    ? capitalGuardRollup.triggers
                    : ["NONE"])
                    .map((trigger) => `<span class="chip">${escapeHtml(String(trigger))}</span>`)
                    .join("")}
                </div>
              </div>
            </div>
            ${
              systems.length === 0
                ? `<div class="muted">No portfolio system snapshots available yet.</div>`
                : `<div class="portfolio-grid">${systems
                    .map(
                      (system) => `<div class="mini-card">
                        <h3>${escapeHtml(system.label || system.id || "System")}</h3>
                        <div class="chips">
                          <span class="chip">Score ${fmtNum((Number(system.score) || 0) * 100, 1)}</span>
                          <span class="status-pill ${escapeHtml(system.status || "red")}">${escapeHtml(String(system.status || "red").toUpperCase())}</span>
                        </div>
                        <div class="kv" style="margin-top:8px">
                          <div class="k">Net delta</div><div>${fmtNum(system.netDelta, 4)}</div>
                          <div class="k">Leverage</div><div>${fmtNum(system.leverage, 2)}</div>
                          <div class="k">Liq buffer</div><div>${fmtPct(system.liqBufferPct)}</div>
                          <div class="k">Health</div><div>${escapeHtml(String(system?.health?.overall || "n/a").toUpperCase())}</div>
                          <div class="k">Hedge / Liq / Range</div>
                          <div>${escapeHtml(String(system?.health?.hedge || "n/a").toUpperCase())} / ${escapeHtml(String(system?.health?.liquidation || "n/a").toUpperCase())} / ${escapeHtml(String(system?.health?.range || "n/a").toUpperCase())}</div>
                          <div class="k">Capital Guard</div><div>${escapeHtml(String(system?.capitalGuard?.level || "none").toUpperCase())}</div>
                        </div>
                        <div class="chips" style="margin-top:8px;">
                          ${(() => {
                            const flags = Array.isArray(system.riskFlags) ? [...system.riskFlags] : [];
                            if (mode.monitorCadenceHours === 48 && !flags.includes("LOW_MONITORING")) flags.push("LOW_MONITORING");
                            if (!isMissingValue(system.liqBufferPct) && Number(system.liqBufferPct) <= mode.minLiqBufferPct * 100) flags.push("LOW_LIQ_BUFFER");
                            return flags.length ? Array.from(new Set(flags)) : ["NONE"];
                          })().map((f) => `<span class="chip">${escapeHtml(f)}</span>`).join("")}
                        </div>
                        <div class="chips" style="margin-top:6px;">
                          ${(Array.isArray(system?.capitalGuard?.triggers) && system.capitalGuard.triggers.length
                            ? system.capitalGuard.triggers
                            : ["NONE"]).map((trigger) => `<span class="chip">${escapeHtml(String(trigger))}</span>`).join("")}
                        </div>
                      </div>`
                    )
                    .join("")}</div>`
            }
          </section>`;
      }

      // OPERATOR_ACTION_PANEL_START
      // Ordering: engine-provided order (deterministic). UI must not sort.
      function getOperatorReasons(solSystem) {
        const fromScoreObj = Array.isArray(solSystem?.scoreObj?.reasons) ? solSystem.scoreObj.reasons : [];
        if (fromScoreObj.length > 0) return fromScoreObj;
        const fromScore = Array.isArray(solSystem?.score?.reasons) ? solSystem.score.reasons : [];
        if (fromScore.length > 0) return fromScore;
        const fromSnapshot = Array.isArray(solSystem?.snapshot?.reasons) ? solSystem.snapshot.reasons : [];
        return fromSnapshot;
      }

      function escapeJsonBlock(value) {
        return escapeHtml(JSON.stringify(value ?? null, null, 2));
      }

      async function copyTextValue(text) {
        if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
          await navigator.clipboard.writeText(text);
          return;
        }
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
      }

      function operatorCopyPayload(kind) {
        const summary = runtimeState.latestPositionsSummary;
        const solSystem = summary?.solSystem ?? null;
        const reasons = getOperatorReasons(solSystem);
        const triggers = Array.isArray(solSystem?.capitalGuard?.triggers) ? solSystem.capitalGuard.triggers : [];
        const guardLevel = String(solSystem?.capitalGuard?.level ?? "none");
        const actionTextLines = [`LEVEL: ${guardLevel}`];
        if (triggers.length > 0) {
          actionTextLines.push("TRIGGERS:");
          for (const trigger of triggers) actionTextLines.push(`- ${String(trigger)}`);
        } else {
          actionTextLines.push("TRIGGERS: (none)");
        }
        if (reasons.length > 0) {
          actionTextLines.push("REASONS:");
          for (const reason of reasons) actionTextLines.push(`- ${String(reason)}`);
        } else {
          actionTextLines.push("REASONS: (none)");
        }
        if (kind === "triggers") {
          return triggers.length ? triggers.join("\n") : "No triggers";
        }
        if (kind === "reasons") {
          return reasons.length ? reasons.join("\n") : "No reasons";
        }
        if (kind === "actionText") {
          return actionTextLines.join("\n");
        }
        if (kind === "debug") {
          return JSON.stringify(solSystem?.snapshot?.debugMath ?? null, null, 2);
        }
        return JSON.stringify(summary ?? null, null, 2);
      }

      function renderOperatorActionPanel(summaryPayload) {
        if (!runtimeState.operatorModeEnabled) return "";
        const solSystem = summaryPayload?.solSystem ?? null;
        const score = solSystem?.scoreObj ?? solSystem?.score ?? null;
        const reasons = getOperatorReasons(solSystem);
        const triggers = Array.isArray(solSystem?.capitalGuard?.triggers) ? solSystem.capitalGuard.triggers : [];
        const healthOverall = String(solSystem?.health?.overall ?? "n/a").toUpperCase();
        const guardLevel = String(solSystem?.capitalGuard?.level ?? "none").toUpperCase();
        const scoreLabel = String(score?.label ?? "n/a");
        const scoreValue = score?.score0to100;
        const copyStatus = runtimeState.operatorSummaryError ? `Summary fetch error: ${runtimeState.operatorSummaryError}` : "";
        const actionText = operatorCopyPayload("actionText");

        return `
          <section class="card section operator-panel">
            <h2>Operator Mode Action Panel</h2>
            <div class="muted" style="margin-bottom:8px;">Display-only canonical controls from <code>/api/positions?mode=summary</code>.</div>
            <div class="panel-grid">
              <div class="mini-card">
                <h3>Attention Summary</h3>
                <div class="kv" style="margin-top:8px;">
                  <div class="k">Capital Guard</div><div>${escapeHtml(guardLevel)}</div>
                  <div class="k">Health</div><div>${escapeHtml(healthOverall)}</div>
                  <div class="k">Score</div><div>${escapeHtml(scoreLabel)} ${scoreValue != null ? `(${escapeHtml(String(scoreValue))})` : ""}</div>
                </div>
              </div>
              <div class="mini-card">
                <h3>Triggers</h3>
                ${
                  triggers.length
                    ? `<ul>${triggers.map((trigger) => `<li>${escapeHtml(String(trigger))}</li>`).join("")}</ul>`
                    : `<div class="muted">No triggers</div>`
                }
              </div>
              <div class="mini-card">
                <h3>Reasons</h3>
                ${
                  reasons.length
                    ? `<ul>${reasons.map((reason) => `<li>${escapeHtml(String(reason))}</li>`).join("")}</ul>`
                    : `<div class="muted">No reasons</div>`
                }
              </div>
              <div class="mini-card">
                <h3>Action Text</h3>
                <textarea readonly>${escapeHtml(actionText)}</textarea>
              </div>
              <div class="mini-card">
                <h3>Debug Math (raw)</h3>
                <pre>${escapeJsonBlock(solSystem?.snapshot?.debugMath ?? null)}</pre>
              </div>
            </div>
            <div class="copy-row">
              <button class="copy-btn" type="button" data-copy-source="triggers">Copy Triggers</button>
              <button class="copy-btn" type="button" data-copy-source="reasons">Copy Reasons</button>
              <button class="copy-btn" type="button" data-copy-source="actionText">Copy Action Text</button>
              <button class="copy-btn" type="button" data-copy-source="debug">Copy Debug Math</button>
              <button class="copy-btn" type="button" data-copy-source="summary">Copy Full Summary JSON</button>
              <span id="operatorCopyStatus" class="copy-status">${escapeHtml(copyStatus)}</span>
            </div>
          </section>
        `;
      }
      // OPERATOR_ACTION_PANEL_END

      function renderShortlist(shortlist) {
        const items = Array.isArray(shortlist?.selected) ? shortlist.selected : [];
        if (items.length === 0) {
          return `<section class="card section"><h2>Shortlist</h2><div class="muted">No pools qualified under current regime guardrails.</div></section>`;
        }
        return `
          <section class="card section">
            <h2>Shortlist (max ${shortlist.maxPools || 2})</h2>
            <div class="muted" style="margin-bottom:8px;">Selected due to score (feeAPR, volume/TVL, depth, stability) under current regime risk settings.</div>
            <div class="grid-2">
              ${items
                .filter((x) => x.type !== "STABLE-STABLE")
                .map(
                  (x) => `
                <div class="mini-card">
                  <h3>${escapeHtml(x.pool)} <span class="muted">#${x.rank}</span></h3>
                  <div class="chips">
                    <span class="chip">${escapeHtml(x.type)}</span>
                    <span class="chip">Score ${fmtNum(x.score, 2)}</span>
                    <span class="chip">FeeAPR ${fmtPct(x.feeAprPct)}</span>
                  </div>
                  <div class="kv" style="margin-top:8px">
                    <div class="k">TVL</div><div>${fmtUsd(x.tvlUsd)}</div>
                    <div class="k">Volume24h</div><div>${fmtUsd(x.volume24hUsd)}</div>
                    <div class="k">Depth ±1%</div><div>${x.depthUsd1Pct != null ? fmtUsd(x.depthUsd1Pct) : "n/a"} ${x.depthTvl1PctRatio != null ? `<span class="muted">(${fmtNum(x.depthTvl1PctRatio * 100, 2)}% TVL)</span>` : ""}</div>
                  </div>
                  <ul class="muted" style="margin:8px 0 0; padding-left:18px;">
                    ${(x.reasons || []).map((r) => `<li>${escapeHtml(r.message)}</li>`).join("")}
                  </ul>
                </div>`
                )
                .join("")}
            </div>
          </section>`;
      }

      function renderPlans(plans) {
        const rows = Array.isArray(plans?.plans) ? plans.plans.filter((p) => p.type !== "STABLE-STABLE") : [];
        return `
          <section class="card section">
            <h2>Plans</h2>
            ${
              rows.length === 0
                ? `<div class="muted">No plan rows available.</div>`
                : `<div class="grid-2">
              ${rows
                .map(
                  (p) => `
                <div class="mini-card">
                  <h3>${escapeHtml(p.pool)}</h3>
                  <div class="chips">
                    <span class="chip">${escapeHtml(p.type)}</span>
                    <span class="chip">Vol proxy ${fmtPct(p.volatilityProxyPctAnnual)}</span>
                    <span class="chip">Spot ${p.spotPrice != null ? fmtNum(p.spotPrice, 6) : "n/a"}</span>
                  </div>
                  <div class="muted" style="margin-top:8px; font-size:0.82rem;">Regime multiplier: ${fmtNum(p.regimeWidthMultiplier, 2)} (${escapeHtml(plans?.regime?.label || "n/a")})</div>
                  <div style="margin-top:8px; font-size:0.85rem;">
                    ${(p.presets || [])
                      .map((pr) => {
                        const mode = getOperatorMode(runtimeState.monitorCadenceHours);
                        const preferred = p.recommendedPreset || (mode.presetBias === "CONSERVATIVE" ? "Conservative" : "Base");
                        const cls = pr.label === preferred ? "preset-recommended" : "";
                        const tag = pr.label === preferred ? ` <span class="chip">Recommended</span>` : "";
                        return `<div class="${cls}"><strong>${pr.label}</strong>${tag}: ${fmtNum(pr.lowerPct, 2)}% / +${fmtNum(pr.upperPct, 2)}% ${pr.lowerPrice != null && pr.upperPrice != null ? `<span class="muted">(${fmtNum(pr.lowerPrice, 6)} - ${fmtNum(pr.upperPrice, 6)})</span>` : ""}</div>`;
                      })
                      .join("")}
                  </div>
                  <div style="margin-top:8px; font-size:0.85rem;">
                    <strong>Hedge</strong>: ${escapeHtml(p.hedge?.side || "NONE")} ${p.hedge?.enabled ? `| ${fmtNum(p.hedge.recommendedShortSolPer10kUsd, 4)} SOL / ${fmtUsd(p.hedge.recommendedShortNotionalUsdPer10kUsd)} per $10k` : ""}
                    <div class="muted">Deposit ratio: ${
                      p.hedge?.depositRatioTokenARatioUSD != null && p.hedge?.depositRatioTokenBRatioUSD != null
                        ? `${fmtNum(p.hedge.depositRatioTokenARatioUSD * 100, 1)}% ${escapeHtml(p.hedge.depositRatioTokenASymbol || "A")} / ${fmtNum(p.hedge.depositRatioTokenBRatioUSD * 100, 1)}% ${escapeHtml(p.hedge.depositRatioTokenBSymbol || "B")} <span class="muted">(${escapeHtml(p.hedge.depositRatioSource || "fallback")})</span>`
                        : `n/a <span class="muted">(${escapeHtml(p.hedge?.depositRatioSource || "fallback")})</span>`
                    }</div>
                    <div class="muted">Delta fraction (est): ${p.hedge?.approxDeltaFraction != null ? fmtNum(p.hedge.approxDeltaFraction, 3) : "n/a"} | Hedge multiplier: ${p.hedge?.hedgeMultiplier != null ? fmtNum(p.hedge.hedgeMultiplier, 2) : "n/a"}</div>
                    <div class="muted">${escapeHtml(p.hedge?.note || "")}</div>
                    ${p.hedge?.warning ? `<div class="muted" style="color:#ffd0d0">${escapeHtml(p.hedge.warning)}</div>` : ""}
                  </div>
                </div>`
                )
                .join("")}
            </div>`
            }
          </section>`;
      }

      function renderAlerts(alerts) {
        const rows = Array.isArray(alerts?.alerts) ? [...alerts.alerts] : [];
        const extra = cadenceRangeAlerts(runtimeState.latestData?.plans);
        rows.push(...extra);
        return `
          <section class="card section">
            <h2>Alerts</h2>
            ${
              rows.length === 0
                ? `<div class="muted">No active alerts from current thresholds.</div>`
                : `<div class="alert-list">
              ${rows
                .map(
                  (a) => `<div class="alert ${a.severity || "info"}"><strong>${escapeHtml(a.kind || "ALERT")}</strong> ${a.pool ? `<span class="muted">(${escapeHtml(a.pool)})</span>` : ""}<div>${escapeHtml(a.message || "")}</div></div>`
                )
                .join("")}
            </div>`
            }
          </section>`;
      }

      function renderAllocation(allocation) {
        const rows = Array.isArray(allocation?.allocations) ? allocation.allocations : [];
        return `
          <section class="card section">
            <h2>Allocation</h2>
            <div class="muted" style="margin-bottom:8px;">Type-neutral allocation uses shortlisted pool scores; regime still controls risk settings (ranges, hedges, alerts).</div>
            ${
              rows.length === 0
                ? `<div class="muted">No allocation recommendation available.</div>`
                : `<div class="grid-2">
                    ${rows
                      .map(
                        (a) => `<div class="mini-card">
                          <h3>${escapeHtml(a.pool)}</h3>
                          <div class="chips">
                            <span class="chip">${escapeHtml(a.type)}</span>
                            <span class="chip">${fmtNum(a.weightPct, 0)}%</span>
                          </div>
                          <div class="muted" style="margin-top:8px;">${escapeHtml(a.rationale || "")}</div>
                        </div>`
                      )
                      .join("")}
                   </div>`
            }
            ${Array.isArray(allocation?.rationale) && allocation.rationale.length ? `<ul class="muted" style="margin:10px 0 0; padding-left:18px;">${allocation.rationale.map((r) => `<li>${escapeHtml(r)}</li>`).join("")}</ul>` : ""}
          </section>`;
      }

      function roundNearest10(n) {
        return Math.round(Number(n || 0) / 10) * 10;
      }

      function computeDeployRows(allocation, plans, totalUsd, roundTo10, leverageX, bufferPct) {
        const allocs = Array.isArray(allocation?.allocations) ? allocation.allocations : [];
        const planByPool = new Map((Array.isArray(plans?.plans) ? plans.plans : []).map((p) => [p.poolAddress, p]));
        const warnings = [];
        const lev = Number.isFinite(Number(leverageX)) && Number(leverageX) > 0 ? Number(leverageX) : 2.5;
        const buffer = Math.max(0, Math.min(100, Number(bufferPct || 0)));
        const bufferMultiplier = 1 + buffer / 100;
        const priceUSDByMint = runtimeState.livePrices?.byMint || {};
        const liveSpot = Number(runtimeState.liveSpot?.priceUsd);
        const hasLiveSpot = Number.isFinite(liveSpot) && liveSpot > 0;
        const rows = allocs.map((a) => {
          const w = Number(a.weightPct || 0) / 100;
          const rawAlloc = totalUsd * w;
          const plan = planByPool.get(a.poolAddress);
          const hedgeUsdPer10k = Number(plan?.hedge?.hedgeUSDPer10k);
          const hedgeSolPer10k = Number(plan?.hedge?.hedgeSOLPer10k);
          const hasHedgeUsd = Number.isFinite(hedgeUsdPer10k);
          const hasHedgeSolFallback = Number.isFinite(hedgeSolPer10k);
          if (!hasHedgeUsd) warnings.push(`Missing hedge USD sizing field for ${a.pool}`);
          if (!hasLiveSpot && !hasHedgeSolFallback) warnings.push(`Missing live spot and hedge SOL fallback for ${a.pool}`);
          const hedgeUsd = hasHedgeUsd ? (rawAlloc / 10000) * hedgeUsdPer10k : null;
          const hedgeSol = hedgeUsd != null && hasLiveSpot ? hedgeUsd / liveSpot : hasHedgeSolFallback ? (rawAlloc / 10000) * hedgeSolPer10k : null;
          const tokenA = plan?.tokenA || null;
          const tokenB = plan?.tokenB || null;
          const ratioA = Number(plan?.hedge?.depositRatioTokenARatioUSD);
          const ratioB = Number(plan?.hedge?.depositRatioTokenBRatioUSD);
          const priceAUSD = tokenA?.mint ? Number(priceUSDByMint[tokenA.mint]) : NaN;
          const priceBUSD = tokenB?.mint ? Number(priceUSDByMint[tokenB.mint]) : NaN;
          let depositAmtA = null;
          let depositAmtB = null;
          if (!(Number.isFinite(ratioA) && Number.isFinite(ratioB))) {
            warnings.push(`Missing deposit ratio for ${a.pool}; cannot compute deposit amounts.`);
          } else {
            if (Number.isFinite(priceAUSD) && priceAUSD > 0) depositAmtA = (rawAlloc * ratioA) / priceAUSD;
            else warnings.push(`Missing USD price for ${tokenA?.symbol || "Token A"}; cannot compute deposit amount.`);
            if (Number.isFinite(priceBUSD) && priceBUSD > 0) depositAmtB = (rawAlloc * ratioB) / priceBUSD;
            else warnings.push(`Missing USD price for ${tokenB?.symbol || "Token B"}; cannot compute deposit amount.`);
          }
          return {
            poolAddress: a.poolAddress,
            pool: a.pool,
            weightPct: Number(a.weightPct || 0),
            allocUsd: rawAlloc,
            hedgeUsd,
            hedgeSol,
            collateralUsd: hedgeUsd != null ? hedgeUsd / lev : null,
            collateralBufferedUsd: hedgeUsd != null ? (hedgeUsd / lev) * bufferMultiplier : null,
            tokenA,
            tokenB,
            depositRatioA: Number.isFinite(ratioA) ? ratioA : null,
            depositRatioB: Number.isFinite(ratioB) ? ratioB : null,
            priceAUSD: Number.isFinite(priceAUSD) ? priceAUSD : null,
            priceBUSD: Number.isFinite(priceBUSD) ? priceBUSD : null,
            depositAmtA,
            depositAmtB
          };
        });

        if (roundTo10 && rows.length > 0) {
          let roundedSum = 0;
          for (let i = 0; i < rows.length - 1; i += 1) {
            rows[i].allocUsd = roundNearest10(rows[i].allocUsd);
            roundedSum += rows[i].allocUsd;
          }
          rows[rows.length - 1].allocUsd = Math.max(0, Number(totalUsd) - roundedSum);
          for (const r of rows) {
            const plan = planByPool.get(r.poolAddress);
            const hedgeUsdPer10k = Number(plan?.hedge?.hedgeUSDPer10k);
            const hedgeSolPer10k = Number(plan?.hedge?.hedgeSOLPer10k);
            if (Number.isFinite(hedgeUsdPer10k)) {
              r.hedgeUsd = (r.allocUsd / 10000) * hedgeUsdPer10k;
              if (hasLiveSpot) r.hedgeSol = r.hedgeUsd / liveSpot;
              else if (Number.isFinite(hedgeSolPer10k)) r.hedgeSol = (r.allocUsd / 10000) * hedgeSolPer10k;
              r.collateralUsd = r.hedgeUsd / lev;
              r.collateralBufferedUsd = r.collateralUsd * bufferMultiplier;
            }
            const priceAUSD = r.tokenA?.mint ? Number(priceUSDByMint[r.tokenA.mint]) : NaN;
            const priceBUSD = r.tokenB?.mint ? Number(priceUSDByMint[r.tokenB.mint]) : NaN;
            if (Number.isFinite(r.depositRatioA) && Number.isFinite(priceAUSD) && priceAUSD > 0) {
              r.priceAUSD = priceAUSD;
              r.depositAmtA = (r.allocUsd * r.depositRatioA) / priceAUSD;
            }
            if (Number.isFinite(r.depositRatioB) && Number.isFinite(priceBUSD) && priceBUSD > 0) {
              r.priceBUSD = priceBUSD;
              r.depositAmtB = (r.allocUsd * r.depositRatioB) / priceBUSD;
            }
          }
        }

        const totalAllocation = rows.reduce((a, r) => a + (Number(r.allocUsd) || 0), 0);
        const totalHedgeUsd = rows.reduce((a, r) => a + (Number.isFinite(r.hedgeUsd) ? r.hedgeUsd : 0), 0);
        const totalHedgeSol = rows.reduce((a, r) => a + (Number.isFinite(r.hedgeSol) ? r.hedgeSol : 0), 0);
        const totalCollateralBase = rows.reduce((a, r) => a + (Number.isFinite(r.collateralUsd) ? r.collateralUsd : 0), 0);
        const totalCollateralBuffered = rows.reduce((a, r) => a + (Number.isFinite(r.collateralBufferedUsd) ? r.collateralBufferedUsd : 0), 0);
        const totalCapitalRequired = totalAllocation + totalCollateralBuffered;
        const tokenTotalsMap = new Map();
        for (const r of rows) {
          if (r.tokenA?.mint && Number.isFinite(r.depositAmtA)) {
            const t = tokenTotalsMap.get(r.tokenA.mint) ?? {
              mint: r.tokenA.mint,
              symbol: r.tokenA.symbol,
              decimals: r.tokenA.decimals,
              priceUSD: r.priceAUSD,
              amount: 0
            };
            t.amount += r.depositAmtA;
            tokenTotalsMap.set(r.tokenA.mint, t);
          }
          if (r.tokenB?.mint && Number.isFinite(r.depositAmtB)) {
            const t = tokenTotalsMap.get(r.tokenB.mint) ?? {
              mint: r.tokenB.mint,
              symbol: r.tokenB.symbol,
              decimals: r.tokenB.decimals,
              priceUSD: r.priceBUSD,
              amount: 0
            };
            t.amount += r.depositAmtB;
            tokenTotalsMap.set(r.tokenB.mint, t);
          }
        }
        return {
          rows,
          warnings,
          totalAllocation,
          totalHedgeUsd,
          totalHedgeSol,
          totalCollateralBase,
          totalCollateralBuffered,
          totalCapitalRequired,
          tokenTotals: [...tokenTotalsMap.values()],
          bufferMultiplier
        };
      }

      function calcSpotForLiquidation(plans) {
        const live = Number(runtimeState.liveSpot?.priceUsd);
        if (Number.isFinite(live) && live > 0) return { spot: live, label: "live prices (SOL)" };
        const spots = (Array.isArray(plans?.plans) ? plans.plans : [])
          .map((p) => Number(p?.spotPrice))
          .filter((x) => Number.isFinite(x) && x > 0);
        if (spots.length === 0) return { spot: null, label: "n/a" };
        if (spots.length === 1) return { spot: spots[0], label: "first plan spot" };
        const avg = spots.reduce((a, b) => a + b, 0) / spots.length;
        return { spot: avg, label: "avg plan spot" };
      }

      function liquidationBand(adversePct) {
        if (adversePct >= 20) return "green";
        if (adversePct >= 12) return "yellow";
        return "red";
      }

      function computeLiqBuffer(calc, plans, mmrPct) {
        const notional = Number(calc?.totalHedgeUsd || 0);
        const collateral = Number(calc?.totalCollateralBuffered || 0);
        const mmr = Math.max(0, Number(mmrPct || 0)) / 100;
        const spotRef = calcSpotForLiquidation(plans);
        let xLiq = notional > 0 ? collateral / notional - mmr : 0;
        const insufficient = xLiq <= 0;
        xLiq = Math.max(0, xLiq);
        const liqPriceApprox = spotRef.spot && xLiq > 0 ? spotRef.spot * (1 + xLiq) : null;

        const shocks = [5, 10, 15, 20].map((shockPct) => {
          const equityAfter = collateral - notional * (shockPct / 100);
          const marginRatioAfter = notional > 0 ? equityAfter / notional : 0;
          return {
            shockPct,
            equityAfter,
            marginRatioAfter,
            liqRisk: marginRatioAfter <= mmr
          };
        });

        return { notional, collateral, mmr, xLiq, insufficient, liqPriceApprox, spotRef, shocks };
      }

      function renderDeployCalculator(allocation, plans) {
        const calcId = `deploy-calc-${Math.random().toString(36).slice(2, 8)}`;
        const rows = Array.isArray(allocation?.allocations) ? allocation.allocations : [];
        return `
          <section class="card section" id="${calcId}">
            <h2>Deploy Calculator</h2>
            <div class="row" style="margin-bottom:10px;">
              <label class="muted">Total Deposit (USD)</label>
              <input class="input" type="number" min="0" step="10" value="3000" data-role="deposit" />
              <label class="muted row" style="gap:6px;">
                <input type="checkbox" checked data-role="round10" />
                <span>Round to nearest $10</span>
              </label>
              <label class="muted">Leverage (x)</label>
              <input class="input" type="number" min="0.1" step="0.1" value="2.5" data-role="leverage" style="min-width:90px;" />
              <label class="muted">Collateral Buffer %</label>
              <input class="input" type="number" min="0" max="100" step="1" value="30" data-role="bufferPct" style="min-width:90px;" />
            </div>
            <div class="muted" style="margin-bottom:10px; font-size:0.82rem;">Buffer increases required collateral to reduce liquidation risk.</div>
            ${
              rows.length === 0
                ? `<div class="muted">No allocation rows available.</div>`
                : `<div data-role="calc-out"></div>`
            }
            <div class="muted" style="margin-top:10px; font-size:0.82rem;">
              Hedge sizing derived from plan hedge per $10k and scaled to your total deployment; assumes SHORT_SOL.
              <br/>Collateral = hedge notional / leverage; excludes buffer and fees. Recommended to add safety buffer.
              <br/>Collateral assumes fixed leverage and does not account for funding, fees, or rapid price gaps. Maintain additional margin if volatility increases.
              <br/>Deposit amounts use current deposit ratio and live USD prices; final required amounts may vary due to liquidity slippage and price movement.
            </div>
          </section>`;
      }

      function renderLiqBufferCard() {
        const id = `liq-buffer-${Math.random().toString(36).slice(2, 8)}`;
        return `
          <section class="card section" id="${id}">
            <h2>Liquidation Buffer (Hedge)</h2>
            <div class="row" style="margin-bottom:10px;">
              <label class="muted">Maintenance Margin %</label>
              <input class="input" type="number" min="0" max="100" step="0.1" value="6.0" data-role="mmrPct" style="min-width:90px;" />
              <span class="muted" data-role="liq-shared"></span>
            </div>
            <div data-role="liq-out"></div>
            <div class="muted" style="margin-top:10px; font-size:0.82rem;">
              This is a planning approximation. Actual Jupiter liquidation depends on their margin model, fees, and oracle pricing. Use as a buffer gauge.
            </div>
          </section>`;
      }

      function mountDeployCalculator(sectionEl, allocation, plans) {
        if (!sectionEl) return;
        const depositInput = sectionEl.querySelector('[data-role="deposit"]');
        const roundInput = sectionEl.querySelector('[data-role="round10"]');
        const leverageInput = sectionEl.querySelector('[data-role="leverage"]');
        const bufferInput = sectionEl.querySelector('[data-role="bufferPct"]');
        const out = sectionEl.querySelector('[data-role="calc-out"]');
        if (!depositInput || !roundInput || !leverageInput || !bufferInput || !out) return;

        const renderCalc = () => {
          const totalUsd = Math.max(0, Number(depositInput.value || 0));
          const roundTo10 = Boolean(roundInput.checked);
          const leverageX = Math.max(0.1, Number(leverageInput.value || 2.5));
          const bufferPct = Math.max(0, Math.min(100, Number(bufferInput.value || 30)));
          const calc = computeDeployRows(allocation, plans, totalUsd, roundTo10, leverageX, bufferPct);
          runtimeState.calc = {
            ...calc,
            totalUsd,
            roundTo10,
            leverageX,
            bufferPct
          };
          out.innerHTML = `
            ${calc.warnings.length ? `<div class="muted" style="color:#ffd0d0; margin-bottom:8px;">${calc.warnings.map(escapeHtml).join("<br/>")}</div>` : ""}
            <table class="calc-table">
              <thead>
                <tr>
                  <th>Pool</th>
                  <th>Weight %</th>
                  <th>Allocation USD</th>
                  <th>Hedge USD</th>
                  <th>Hedge SOL</th>
                  <th>Deposit Token A</th>
                  <th>Deposit Token B</th>
                  <th>Collateral (${fmtNum(leverageX, 2)}x)</th>
                  <th>Collateral w/ Buffer</th>
                </tr>
              </thead>
              <tbody>
                ${calc.rows
                  .map(
                    (r) => `<tr>
                      <td>${escapeHtml(r.pool)}</td>
                      <td>${fmtNum(r.weightPct, 0)}%</td>
                      <td>${fmtUsd(r.allocUsd)}</td>
                      <td>${Number.isFinite(r.hedgeUsd) ? fmtUsd(r.hedgeUsd) : "—"}</td>
                      <td>${Number.isFinite(r.hedgeSol) ? fmtNum(r.hedgeSol, 4) : "—"}</td>
                      <td>${displayTokenAmount(r.depositAmtA, r.tokenA?.symbol, r.tokenA?.decimals, r.priceAUSD)}</td>
                      <td>${displayTokenAmount(r.depositAmtB, r.tokenB?.symbol, r.tokenB?.decimals, r.priceBUSD)}</td>
                      <td>${Number.isFinite(r.collateralUsd) ? fmtUsd(r.collateralUsd) : "—"}</td>
                      <td>${Number.isFinite(r.collateralBufferedUsd) ? fmtUsd(r.collateralBufferedUsd) : "—"}</td>
                    </tr>`
                  )
                  .join("")}
              </tbody>
            </table>`;
          out.innerHTML += `
            <div class="mini-card" style="margin-top:10px;">
              <div class="kv">
                <div class="k">Total LP Deposit</div><div><strong>${fmtUsd(calc.totalAllocation)}</strong></div>
                <div class="k">Total Hedge USD</div><div><strong>${fmtUsd(calc.totalHedgeUsd)}</strong></div>
                <div class="k">Total Hedge SOL</div><div><strong>${fmtNum(calc.totalHedgeSol, 4)}</strong></div>
                <div class="k">Total Collateral (Base)</div><div><strong>${fmtUsd(calc.totalCollateralBase)}</strong></div>
                <div class="k">Total Collateral (Buffered)</div><div><strong>${fmtUsd(calc.totalCollateralBuffered)}</strong> <span class="muted">(${fmtNum((calc.bufferMultiplier - 1) * 100, 0)}% buffer)</span></div>
                <div class="k">Total Capital Required</div><div><strong>${fmtUsd(calc.totalCapitalRequired)}</strong></div>
              </div>
            </div>`;
          out.innerHTML += `
            <div class="mini-card" style="margin-top:10px;">
              <div class="muted" style="margin-bottom:6px;">Token Totals</div>
              ${
                Array.isArray(calc.tokenTotals) && calc.tokenTotals.length
                  ? calc.tokenTotals
                      .map((t) => `<div>${escapeHtml(t.symbol || t.mint)}: <strong>${displayTokenAmount(t.amount, t.symbol, t.decimals, t.priceUSD)}</strong></div>`)
                      .join("")
                  : `<div class="muted">No token totals available.</div>`
              }
            </div>`;
          };

        depositInput.addEventListener("input", renderCalc);
        roundInput.addEventListener("change", renderCalc);
        leverageInput.addEventListener("input", renderCalc);
        bufferInput.addEventListener("input", renderCalc);
        renderCalc();
      }

      function mountLiqBuffer(sectionEl, deploySection, plans) {
        if (!sectionEl || !deploySection) return;
        const out = sectionEl.querySelector('[data-role="liq-out"]');
        const mmrInput = sectionEl.querySelector('[data-role="mmrPct"]');
        const shared = sectionEl.querySelector('[data-role="liq-shared"]');
        const leverageInput = deploySection.querySelector('[data-role="leverage"]');
        const bufferInput = deploySection.querySelector('[data-role="bufferPct"]');
        const depositInput = deploySection.querySelector('[data-role="deposit"]');
        if (!out || !mmrInput || !shared || !leverageInput || !bufferInput || !depositInput) return;

        const renderLiq = () => {
          const calc = runtimeState.calc;
          const mmrPct = Math.max(0, Math.min(100, Number(mmrInput.value || 6)));
          shared.textContent = `Using leverage ${Number(leverageInput.value || 2.5).toFixed(2)}x and buffer ${Number(bufferInput.value || 30).toFixed(0)}% from Deploy Calculator`;
          if (!calc) {
            out.innerHTML = `<div class="muted">Waiting for deploy calculator values...</div>`;
            return;
          }
          const liq = computeLiqBuffer(calc, plans, mmrPct);
          const adversePct = liq.xLiq * 100;
          const gaugeClass = liquidationBand(adversePct);
          const gaugeWidth = Math.max(0, Math.min(100, (adversePct / 30) * 100));

          out.innerHTML = `
            <div class="mini-card">
              <div class="kv">
                <div class="k">Total Hedge Notional</div><div>${fmtUsd(liq.notional)}</div>
                <div class="k">Buffered Collateral</div><div>${fmtUsd(liq.collateral)}</div>
                <div class="k">MMR</div><div>${fmtPct(mmrPct)}</div>
                <div class="k">Spot Reference</div><div>${liq.spotRef.spot != null ? `${fmtNum(liq.spotRef.spot, 4)} (${escapeHtml(liq.spotRef.label)})` : "n/a"}</div>
                <div class="k">Approx Liq Price</div><div>${liq.liqPriceApprox != null ? fmtNum(liq.liqPriceApprox, 4) : liq.insufficient ? "INSUFFICIENT COLLATERAL / TOO MUCH LEVERAGE" : "n/a"}</div>
              </div>
              <div style="margin-top:10px;">
                <div class="muted" style="margin-bottom:6px;">Adverse move to liquidation (approx): <strong>${fmtNum(adversePct, 2)}%</strong></div>
                <div class="gauge"><div class="gauge-fill ${gaugeClass}" style="width:${gaugeWidth}%;"></div></div>
              </div>
            </div>
            <div class="mini-card" style="margin-top:10px;">
              <div class="muted" style="margin-bottom:6px;">Scenario shocks</div>
              <table class="calc-table">
                <thead>
                  <tr>
                    <th>Shock</th>
                    <th>Equity After</th>
                    <th>Margin Ratio After</th>
                    <th>Status</th>
                  </tr>
                </thead>
                <tbody>
                  ${liq.shocks
                    .map((s) => `<tr>
                      <td>+${fmtNum(s.shockPct, 0)}%</td>
                      <td>${fmtUsd(s.equityAfter)}</td>
                      <td>${fmtPct(s.marginRatioAfter * 100, 2)}</td>
                      <td>${s.liqRisk ? '<span style="color:#ff9b9b;">LIQ RISK</span>' : '<span style="color:#9be7b4;">OK</span>'}</td>
                    </tr>`)
                    .join("")}
                </tbody>
              </table>
            </div>
          `;
          if (liq.insufficient) {
            out.innerHTML = `<div class="error">INSUFFICIENT COLLATERAL / TOO MUCH LEVERAGE under current buffer and MMR assumptions.</div>` + out.innerHTML;
          }
        };

        mmrInput.addEventListener("input", renderLiq);
        leverageInput.addEventListener("input", renderLiq);
        bufferInput.addEventListener("input", renderLiq);
        depositInput.addEventListener("input", renderLiq);
        const roundToggle = deploySection.querySelector('[data-role="round10"]');
        if (roundToggle) roundToggle.addEventListener("change", renderLiq);
        sectionEl._renderLiq = renderLiq;
        renderLiq();
      }

      function getStableFallbackPrice(token) {
        if (!token) return null;
        if (STABLE_SYMBOLS.has(normSymbol(token.symbol))) return 1;
        if (token.mint && KNOWN_STABLE_MINTS.has(String(token.mint))) return 1;
        return null;
      }

      function buildLivePriceMapFromPlans(plans) {
        const byMint = {};
        const bySymbol = {};
        const rows = Array.isArray(plans?.plans) ? plans.plans : [];
        const tokens = [];
        for (const p of rows) {
          if (p?.tokenA?.mint) tokens.push(p.tokenA);
          if (p?.tokenB?.mint) tokens.push(p.tokenB);
        }

        for (const t of tokens) {
          const stable = getStableFallbackPrice(t);
          if (stable != null) {
            byMint[t.mint] = stable;
            bySymbol[t.symbol] = stable;
          }
        }

        const liveSol = Number(runtimeState.liveSpot?.priceUsd);
        if (Number.isFinite(liveSol) && liveSol > 0) {
          for (const t of tokens) {
            const s = normSymbol(t.symbol);
            if (s === "SOL" || s === "WSOL") {
              byMint[t.mint] = liveSol;
              bySymbol[t.symbol] = liveSol;
            }
          }
        }

        let changed = true;
        for (let i = 0; i < 8 && changed; i += 1) {
          changed = false;
          for (const p of rows) {
            const a = p?.tokenA;
            const b = p?.tokenB;
            const spot = Number(p?.spotPrice);
            if (!a?.mint || !b?.mint || !(Number.isFinite(spot) && spot > 0)) continue;
            const pa = Number(byMint[a.mint]);
            const pb = Number(byMint[b.mint]);
            if (Number.isFinite(pa) && pa > 0 && !(Number.isFinite(pb) && pb > 0)) {
              byMint[b.mint] = pa / spot; // spot is tokenB per tokenA
              bySymbol[b.symbol] = pa / spot;
              changed = true;
            } else if (Number.isFinite(pb) && pb > 0 && !(Number.isFinite(pa) && pa > 0)) {
              byMint[a.mint] = spot * pb;
              bySymbol[a.symbol] = spot * pb;
              changed = true;
            }
          }
        }

        return { byMint, bySymbol };
      }

      function refreshDerivedLivePrices() {
        const plans = runtimeState.latestData?.plans;
        const derived = buildLivePriceMapFromPlans(plans);
        runtimeState.livePrices.byMint = derived.byMint;
        runtimeState.livePrices.bySymbol = derived.bySymbol;
        runtimeState.livePrices.updatedAt = runtimeState.liveSpot.updatedAt ?? new Date().toISOString();
        runtimeState.livePrices.error = runtimeState.liveSpot.error ?? null;
      }

      function renderLiveSpotHeader() {
        const valueEl = document.getElementById("liveSpotValue");
        const updatedEl = document.getElementById("liveSpotUpdated");
        const errEl = document.getElementById("liveSpotError");
        if (!valueEl || !updatedEl || !errEl) return;
        const entries = Object.entries(runtimeState.livePrices?.bySymbol || {})
          .filter(([, v]) => Number.isFinite(Number(v)) && Number(v) > 0)
          .sort(([a], [b]) => a.localeCompare(b));
        if (entries.length === 0) {
          valueEl.textContent = "Unavailable";
        } else {
          valueEl.innerHTML = entries.slice(0, 8).map(([sym, px]) => `${escapeHtml(sym)} ${fmtUsd(px)}`).join("<br/>");
        }
        updatedEl.textContent = `Live prices updated: ${fmtTime(runtimeState.livePrices?.updatedAt || runtimeState.liveSpot?.updatedAt)}`;
        errEl.textContent = runtimeState.liveSpot?.error ? `Live prices error: ${runtimeState.liveSpot.error}` : "";
      }

      async function fetchLiveSolSpot() {
        const ts = Date.now();

        // Prefer same-origin proxy on Vercel to avoid browser CORS/rate-limit issues.
        try {
          const proxyRes = await fetch(`${LIVE_SOL_SPOT_PROXY_URL}?t=${ts}`, {
            headers: { "cache-control": "no-cache" }
          });
          if (proxyRes.ok) {
            const proxyPayload = await proxyRes.json();
            const proxyPrice = Number(proxyPayload?.priceUsd);
            if (Number.isFinite(proxyPrice) && proxyPrice > 0) return proxyPrice;
          }
        } catch {
          // Fall through to direct fetch for local dev or proxy outages.
        }

        const url = `${LIVE_SOL_SPOT_URL}&t=${ts}`;
        const res = await fetch(url, {
          headers: { "cache-control": "no-cache" }
        });
        if (!res.ok) throw new Error(`live spot HTTP ${res.status}`);
        const payload = await res.json();
        const price = Number(payload?.solana?.usd);
        if (!Number.isFinite(price) || price <= 0) throw new Error("invalid live spot payload");
        return price;
      }

      async function loadLiveSpot(options = {}) {
        const btn = document.getElementById("refreshLiveSpotBtn");
        const manual = Boolean(options.manual);
        if (btn && manual) {
          btn.disabled = true;
          btn.textContent = "Refreshing...";
        }
        try {
          const price = await fetchLiveSolSpot();
          runtimeState.liveSpot.priceUsd = price;
          runtimeState.liveSpot.updatedAt = new Date().toISOString();
          runtimeState.liveSpot.error = null;
          refreshDerivedLivePrices();
          renderLiveSpotHeader();
          const app = document.getElementById("app");
          const liqSection = app?.querySelector?.('[id^="liq-buffer-"]');
          if (liqSection && typeof liqSection._renderLiq === "function") liqSection._renderLiq();
          const deploySection = app?.querySelector?.('[id^="deploy-calc-"]');
          if (deploySection) {
            const depositInput = deploySection.querySelector('[data-role="deposit"]');
            if (depositInput) depositInput.dispatchEvent(new Event("input"));
          }
        } catch (err) {
          runtimeState.liveSpot.error = String(err && err.message ? err.message : err);
          refreshDerivedLivePrices();
          renderLiveSpotHeader();
        } finally {
          if (btn) {
            btn.disabled = false;
            btn.textContent = "Refresh Live Prices";
          }
        }
      }

      function renderPerformance(perf) {
        const summary = perf?.summary || {};
        return `
          <section class="card section">
            <h2>Performance Ledger (7d snapshots)</h2>
            <div class="kv">
              <div class="k">Snapshots</div><div>${summary.snapshotCount ?? 0}</div>
              <div class="k">Avg funding APR</div><div>${fmtPct(summary.avgFundingAprPct)}</div>
              <div class="k">Regime counts</div><div>LOW ${summary.regimeCounts?.LOW ?? 0} / MOD ${summary.regimeCounts?.MODERATE ?? 0} / HIGH ${summary.regimeCounts?.HIGH ?? 0}</div>
              <div class="k">Latest snapshot</div><div>${summary.latestSnapshotTs ? new Date(summary.latestSnapshotTs).toLocaleString() : "n/a"}</div>
            </div>
          </section>`;
      }

      function render(regime, pools, shortlist, plans, allocation, alerts, performance, portfolio, positionsSummary) {
        const app = document.getElementById("app");
        const updatedAt = document.getElementById("updatedAt");
        const status = document.getElementById("status");

        updatedAt.textContent = `Regime: ${regime.regime || "n/a"} | Data updated: ${new Date(
          regime.generatedAt || pools.generatedAt || Date.now()
        ).toLocaleString()}`;
        const allRows = Array.isArray(pools.topPoolsOverall) ? pools.topPoolsOverall : Array.isArray(pools.pools) ? pools.pools : [];
        const rows = allRows.filter((r) => r.type !== "STABLE-STABLE");
        status.textContent = `Loaded ${rows.length} ranked pools (UI-visible).`;

        const metrics = regime.metrics || {};

        app.innerHTML = `
          <div class="stack">
          <section class="card regime">
            <div class="regime-top">
              <div class="pill ${regimeClass(regime.regime)}">
                <span>${regime.regime || "UNKNOWN"}</span>
                <span class="muted">confidence ${fmtNum((Number(regime.confidence) || 0) * 100, 0)}%</span>
              </div>
              <div class="row">
                <div class="muted">Score ${fmtNum(regime.score, 3)}</div>
                ${renderCadenceControl()}
              </div>
            </div>
            <div class="metrics">
              <div class="metric"><div class="label">vol7d</div><div class="value">${fmtPct(metrics.vol7dPct)}</div></div>
              <div class="metric"><div class="label">vol30d</div><div class="value">${fmtPct(metrics.vol30dPct)}</div></div>
              <div class="metric"><div class="label">VR (7d/30d)</div><div class="value">${fmtNum(metrics.vr, 2)}</div></div>
              <div class="metric"><div class="label">Funding APR (proxy)</div><div class="value">${fmtPct(metrics.fundingAprPct)}</div></div>
              <div class="metric"><div class="label">Volume/TVL 24h</div><div class="value">${fmtNum((metrics.volumeTvl24h || 0) * 100, 2)}%</div></div>
              <div class="metric"><div class="label">Volume/TVL trend</div><div class="value">${(metrics.volumeTvlTrendLabel || "unknown").toUpperCase()} ${metrics.volumeTvlTrendRatio ? `(${fmtNum(metrics.volumeTvlTrendRatio, 2)}x)` : ""}</div></div>
            </div>
            <div class="reasons">
              <strong>Drivers</strong>
              <ul>
                ${(Array.isArray(regime.reasons) ? regime.reasons : []).map((x) => `<li>${x}</li>`).join("")}
              </ul>
            </div>
          </section>

          ${renderPortfolioSystems(portfolio)}
          ${renderOperatorActionPanel(positionsSummary)}
          ${renderShortlist(shortlist)}
          ${renderPlans(plans)}
          ${renderAllocation(allocation)}
          ${renderDeployCalculator(allocation, plans)}
          ${renderLiqBufferCard()}
          ${renderAlerts(alerts)}
          ${renderPerformance(performance)}

          <section class="card table-card">
            <div class="table-wrap">
              <table>
                <thead>
                  <tr>
                    <th>Rank</th>
                    <th>Pool</th>
                    <th>Type</th>
                    <th>Fee Tier</th>
                    <th>TVL</th>
                    <th>Volume24h</th>
                    <th>FeeAPR</th>
                    <th>Vol/TVL</th>
                    <th>Depth ±1%</th>
                    <th>Depth ±2%</th>
                    <th>Score</th>
                    <th>Explanation</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows
                    .map(
                      (r) => `
                    <tr>
                      <td>${r.rank ?? ""}</td>
                      <td><div>${r.pool || ""}</div><div class="mono muted">${String(r.poolAddress || "").slice(0, 8)}...</div></td>
                      <td>${r.type || ""}</td>
                      <td>${fmtPct(r.feeTierPct, 4)}</td>
                      <td>${fmtUsd(r.tvlUsd)}</td>
                      <td>${fmtUsd(r.volume24hUsd)}</td>
                      <td>${fmtPct(r.feeAprPct)}</td>
                      <td>${fmtNum((Number(r.volumeTvl) || 0) * 100, 1)}%</td>
                      <td>${r.depthUsd1Pct != null ? fmtUsd(r.depthUsd1Pct) : "n/a"}</td>
                      <td>${r.depthUsd2Pct != null ? fmtUsd(r.depthUsd2Pct) : "n/a"}</td>
                      <td class="score">${fmtNum(r.score, 2)}</td>
                      <td>${r.explanation || ""}</td>
                    </tr>`
                    )
                    .join("")}
                </tbody>
              </table>
            </div>
          </section>
          </div>
        `;

        const deploySection = app.querySelector('[id^="deploy-calc-"]');
        const liqSection = app.querySelector('[id^="liq-buffer-"]');
        mountDeployCalculator(deploySection, allocation, plans);
        mountLiqBuffer(liqSection, deploySection, plans);

        app.querySelectorAll("[data-cadence]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const cadence = Number(btn.getAttribute("data-cadence")) === 48 ? 48 : 24;
            runtimeState.monitorCadenceHours = cadence;
            localStorage.setItem("monitorCadenceHours", String(cadence));
            load({ manual: true, cacheBust: true });
          });
        });

        app.querySelectorAll("[data-copy-source]").forEach((btn) => {
          btn.addEventListener("click", async () => {
            const source = String(btn.getAttribute("data-copy-source") || "summary");
            const statusEl = document.getElementById("operatorCopyStatus");
            try {
              await copyTextValue(operatorCopyPayload(source));
              if (statusEl) statusEl.textContent = `Copied ${source}`;
            } catch (err) {
              if (statusEl) statusEl.textContent = `Copy failed: ${String(err && err.message ? err.message : err)}`;
            }
          });
        });
      }

      async function fetchJson(url, cacheBustTs) {
        const finalUrl = cacheBustTs ? `${url}${url.includes("?") ? "&" : "?"}t=${cacheBustTs}` : url;
        const res = await fetch(finalUrl);
        if (!res.ok) throw new Error(`${url.split("/").pop()}: HTTP ${res.status}`);
        return res.json();
      }

      async function load(options = {}) {
        const status = document.getElementById("status");
        const refreshBtn = document.getElementById("refreshBtn");
        const refreshErr = document.getElementById("refreshInlineError");
        const lastAttempt = document.getElementById("lastRefreshAttempt");
        const manual = Boolean(options.manual);
        const cacheBustTs = options.cacheBust ? Date.now() : undefined;
        if (lastAttempt) lastAttempt.textContent = `Last refresh attempt: ${new Date().toLocaleTimeString()}`;
        if (refreshErr) refreshErr.textContent = "";
        if (refreshBtn && manual) {
          refreshBtn.disabled = true;
          refreshBtn.textContent = "Refreshing...";
        }
        try {
          const operatorWallet = String((operatorWalletInputOrca?.value || runtimeState.operatorWallet || "").trim());
          runtimeState.operatorWallet = operatorWallet || DEFAULT_OPERATOR_WALLET;
          persistOrcaOperatorWallet(runtimeState.operatorWallet);

          const [regime, pools, shortlist, plans, allocation, alerts, performance, portfolio, positionsSummary] = await Promise.all([
            fetchJson(REGIME_URL, cacheBustTs),
            fetchJson(POOLS_URL, cacheBustTs),
            fetchJson(SHORTLIST_URL, cacheBustTs).catch(() => ({ selected: [], maxPools: 2 })),
            fetchJson(PLANS_URL, cacheBustTs).catch(() => ({ plans: [] })),
            fetchJson(ALLOCATION_URL, cacheBustTs).catch(() => ({ allocations: [], rationale: [] })),
            fetchJson(ALERTS_URL, cacheBustTs).catch(() => ({ alerts: [] })),
            fetchJson(PERFORMANCE_URL, cacheBustTs).catch(() => ({ summary: { snapshotCount: 0, regimeCounts: { LOW: 0, MODERATE: 0, HIGH: 0 } } })),
            fetchJson(portfolioIndexUrlForCadence(runtimeState.monitorCadenceHours), cacheBustTs).catch(() => ({ systems: [] })),
            fetchJson(`${POSITIONS_SUMMARY_URL}?wallet=${encodeURIComponent(runtimeState.operatorWallet)}&mode=summary`, cacheBustTs).catch((err) => ({
              __error: String(err && err.message ? err.message : err)
            }))
          ]);
          runtimeState.latestData = { regime, pools, shortlist, plans, allocation, alerts, performance, portfolio };
          runtimeState.latestPositionsSummary = positionsSummary?.__error ? null : positionsSummary;
          runtimeState.operatorSummaryError = positionsSummary?.__error ? String(positionsSummary.__error) : null;
          refreshDerivedLivePrices();
          renderLiveSpotHeader();
          render(regime, pools, shortlist, plans, allocation, alerts, performance, portfolio, runtimeState.latestPositionsSummary);
        } catch (err) {
          const msg = String(err && err.message ? err.message : err);
          if (manual && refreshErr) {
            refreshErr.textContent = `Refresh failed: ${msg}`;
          } else {
            status.innerHTML = `<div class="error">Failed to load Orca dashboard data: ${msg}</div>`;
          }
        } finally {
          if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.textContent = "Refresh";
          }
        }
      }

      const refreshBtn = document.getElementById("refreshBtn");
      if (refreshBtn) {
        refreshBtn.addEventListener("click", () => {
          load({ manual: true, cacheBust: true });
        });
      }

      const refreshLiveSpotBtn = document.getElementById("refreshLiveSpotBtn");
      if (refreshLiveSpotBtn) {
        refreshLiveSpotBtn.addEventListener("click", () => {
          loadLiveSpot({ manual: true });
        });
      }

      if (operatorModeToggleOrca) {
        operatorModeToggleOrca.addEventListener("change", () => {
          runtimeState.operatorModeEnabled = Boolean(operatorModeToggleOrca.checked);
          persistOrcaOperatorModeState(runtimeState.operatorModeEnabled);
          render(
            runtimeState.latestData?.regime || {},
            runtimeState.latestData?.pools || {},
            runtimeState.latestData?.shortlist || {},
            runtimeState.latestData?.plans || {},
            runtimeState.latestData?.allocation || {},
            runtimeState.latestData?.alerts || {},
            runtimeState.latestData?.performance || {},
            runtimeState.latestData?.portfolio || {},
            runtimeState.latestPositionsSummary
          );
        });
      }

      if (operatorWalletInputOrca) {
        operatorWalletInputOrca.addEventListener("change", () => {
          runtimeState.operatorWallet = String(operatorWalletInputOrca.value || "").trim() || DEFAULT_OPERATOR_WALLET;
          persistOrcaOperatorWallet(runtimeState.operatorWallet);
          load({ manual: true, cacheBust: true });
        });
      }

      load();
      loadLiveSpot();
    </script>
  </body>
  </html>
